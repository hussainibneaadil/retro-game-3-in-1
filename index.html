<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RETRO ARCADE | Premium Pixel Games</title>
    <style>
        /* Base Retro Styling */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            font-family: 'Press Start 2P', cursive;
            background-color: #000;
            color: #fff;
            overflow-x: hidden;
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.85), rgba(0, 0, 0, 0.85)),
                url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="50" height="50" x="0" y="0" fill="%23ff00ff" opacity="0.1"/><rect width="50" height="50" x="50" y="50" fill="%23ff00ff" opacity="0.1"/><rect width="50" height="50" x="0" y="50" fill="%2300ffff" opacity="0.1"/><rect width="50" height="50" x="50" y="0" fill="%2300ffff" opacity="0.1"/></svg>');
            background-size: 100px 100px;
            animation: scanlines 0.5s linear infinite;
            image-rendering: pixelated;
        }

        @keyframes scanlines {
            0% { background-position: 0 0; }
            100% { background-position: 0 4px; }
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }

        h1 {
            color: #ff0;
            text-shadow: 0 0 10px #ff0, 0 0 20px #ff0;
            font-size: 3rem;
            margin-bottom: 50px;
            animation: glow 1.5s ease-in-out infinite alternate;
            position: relative;
        }

        h1::after {
            content: "PREMIUM ARCADE";
            position: absolute;
            bottom: -25px;
            left: 0;
            right: 0;
            font-size: 1rem;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }

        @keyframes glow {
            from { text-shadow: 0 0 5px #ff0, 0 0 10px #ff0; }
            to { text-shadow: 0 0 10px #ff0, 0 0 20px #ff0, 0 0 30px #ff0, 0 0 40px #ff0; }
        }

        .game-buttons {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-top: 50px;
        }

        .game-btn {
            position: relative;
            padding: 25px;
            font-size: 1.5rem;
            color: #fff;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            text-transform: uppercase;
            z-index: 1;
            image-rendering: pixelated;
        }

        .game-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        .game-btn:active {
            transform: scale(0.95);
        }

        .game-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: 0.5s;
            z-index: -1;
        }

        .game-btn:hover::before {
            left: 100%;
        }

        .game-btn:nth-child(1) {
            background: linear-gradient(45deg, #ff00ff, #ff0000);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        .game-btn:nth-child(1)::after {
            content: 'CLASSIC';
            position: absolute;
            bottom: 5px;
            right: 10px;
            font-size: 0.8rem;
            color: #fff;
        }

        .game-btn:nth-child(2) {
            background: linear-gradient(45deg, #00ff00, #0000ff);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        .game-btn:nth-child(2)::after {
            content: 'SPEED';
            position: absolute;
            bottom: 5px;
            right: 10px;
            font-size: 0.8rem;
            color: #fff;
        }

        .game-btn:nth-child(3) {
            background: linear-gradient(45deg, #ffff00, #ff6600);
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
        }

        .game-btn:nth-child(3)::after {
            content: 'JUMP';
            position: absolute;
            bottom: 5px;
            right: 10px;
            font-size: 0.8rem;
            color: #fff;
        }

        .game-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 100;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .game-frame {
            width: 90%;
            height: 80%;
            border: 4px solid #ff0;
            box-shadow: 0 0 30px #ff0;
            background: #000;
            image-rendering: pixelated;
        }

        .close-btn {
            margin-top: 20px;
            padding: 12px 25px;
            background: #f00;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .close-btn:hover {
            background: #ff5050;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
        }

        .pixel-corner {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #ff0;
            z-index: 10;
        }

        .top-left { top: 0; left: 0; }
        .top-right { top: 0; right: 0; }
        .bottom-left { bottom: 0; left: 0; }
        .bottom-right { bottom: 0; right: 0; }

        canvas {
            display: block;
            margin: 0 auto;
            image-rendering: pixelated;
        }

        .game-instructions {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 0.8rem;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 2rem;
            }
            
            h1::after {
                font-size: 0.7rem;
                bottom: -20px;
            }
            
            .game-btn {
                font-size: 1.2rem;
                padding: 20px;
            }
            
            .game-frame {
                width: 95%;
                height: 70%;
            }
            
            .game-instructions {
                font-size: 0.6rem;
                bottom: 70px;
            }
        }
    
/* Mobile control buttons */
.mobile-controls {
    display: none;
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 200;
    text-align: center;
}
.mobile-controls button {
    width: 60px;
    height: 60px;
    margin: 5px;
    font-size: 1.5rem;
    font-family: 'Press Start 2P', cursive;
    background: #333;
    color: #0f0;
    border: 2px solid #0f0;
    border-radius: 10px;
}
.mobile-controls .row {
    display: flex;
    justify-content: center;
}
@media (max-width: 600px) {
    .mobile-controls {
        display: block;
    }
}

</style>
</head>
<body>
    <div class="pixel-corner top-left"></div>
    <div class="pixel-corner top-right"></div>
    <div class="pixel-corner bottom-left"></div>
    <div class="pixel-corner bottom-right"></div>

    <div class="container">
        <h1>RETRO ARCADE</h1>
        
        <div class="game-buttons">
            <button class="game-btn" onclick="startGame('snake')">SNAKE GAME</button>
            <button class="game-btn" onclick="startGame('car')">CAR RACING</button>
            <button class="game-btn" onclick="startGame('trex')">T-REX RUNNER</button>
        </div>
    </div>

    <!-- Snake Game Container -->
    <div id="snake-game" class="game-container">
        <canvas id="snake-canvas" class="game-frame" width="600" height="600"></canvas>

<!-- MOBILE CONTROLS FOR SNAKE GAME -->
<div class="mobile-controls" id="mobile-controls">
    <div class="row">
        <button onclick="setDirection('up')">↑</button>
    </div>
    <div class="row">
        <button onclick="setDirection('left')">←</button>
        <button onclick="setDirection('down')">↓</button>
        <button onclick="setDirection('right')">→</button>
    </div>
</div>

        <div class="game-instructions">USE ARROW KEYS TO MOVE | EAT FRUIT TO GROW</div>
        <button class="close-btn" onclick="closeGame('snake')">CLOSE GAME (ESC)</button>
    </div>

    <!-- Car Racing Game Container -->
    <div id="car-game" class="game-container">
        <canvas id="car-canvas" class="game-frame" width="600" height="800"></canvas>

<!-- MOBILE CONTROLS FOR CAR GAME -->
<div class="mobile-controls" id="mobile-controls-car">
    <div class="row">
        <button onclick="setCarDirection('up')">↑</button>
    </div>
    <div class="row">
        <button onclick="setCarDirection('left')">←</button>
        <button onclick="setCarDirection('down')">↓</button>
        <button onclick="setCarDirection('right')">→</button>
    </div>
</div>

        <div class="game-instructions">LEFT/RIGHT ARROWS TO SWITCH LANES | AVOID OBSTACLES</div>
        <button class="close-btn" onclick="closeGame('car')">CLOSE GAME (ESC)</button>
    </div>

    <!-- T-Rex Game Container -->
    <div id="trex-game" class="game-container">
        <canvas id="trex-canvas" class="game-frame" width="800" height="300"></canvas>

<!-- MOBILE CONTROLS FOR TREX GAME -->
<div class="mobile-controls" id="mobile-controls-trex">
    <div class="row">
        <button onclick="setTrexDirection('up')">↑</button>
    </div>
    <div class="row">
        <button onclick="setTrexDirection('none')">×</button>
        <button onclick="setTrexDirection('down')">↓</button>
        <button onclick="setTrexDirection('none')">×</button>
    </div>
</div>

        <div class="game-instructions">SPACE OR UP ARROW TO JUMP | DODGE CACTI</div>
        <button class="close-btn" onclick="closeGame('trex')">CLOSE GAME (ESC)</button>
    </div>

    <script>
        // Game management
        function startGame(game) {
            document.getElementById(game + '-game').style.display = 'flex';
            
            // Initialize the selected game
            switch(game) {
                case 'snake':
                    initSnake();
                    break;
                case 'car':
                    initCarRacing();
                    break;
                case 'trex':
                    initTrex();
                    break;
            }
            
            // Set focus to the game container for keyboard controls
            document.getElementById(game + '-game').focus();
        }
        
        function closeGame(game) {
            document.getElementById(game + '-game').style.display = 'none';
            
            // Reset the game state if needed
            switch(game) {
                case 'snake':
                    snakeGameOver = true;
                    break;
                case 'car':
                    carGameOver = true;
                    break;
                case 'trex':
                    trexGameOver = true;
                    break;
            }
        }

        // Handle ESC key to close games
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                if (document.getElementById('snake-game').style.display === 'flex') {
                    closeGame('snake');
                } else if (document.getElementById('car-game').style.display === 'flex') {
                    closeGame('car');
                } else if (document.getElementById('trex-game').style.display === 'flex') {
                    closeGame('trex');
                }
            }
        });

        // ======================
        // ENHANCED SNAKE GAME
        // ======================
        let snakeCanvas, snakeCtx;
        let snake = [];
        let snakeDirection = 'right';
        let food = {};
        let snakeGameOver = false;
        let snakeSize = 30;
        let snakeSpeed = 10;
        let lastRenderTime = 0;
        let snakeScore = 0;
        let specialFood = null;
        let specialFoodTimer = 0;
        let snakeParticles = [];

        // Snake sprites
        const snakeHeadImg = new Image();
        snakeHeadImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30"><rect x="5" y="5" width="20" height="20" fill="%2300ff00" stroke="%23007700" stroke-width="2"/><circle cx="10" cy="10" r="2" fill="%23000"/><circle cx="20" cy="10" r="2" fill="%23000"/></svg>';

        const snakeBodyImg = new Image();
        snakeBodyImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30"><rect x="5" y="5" width="20" height="20" fill="%2300aa00" stroke="%23007700" stroke-width="2"/></svg>';

        const snakeTailImg = new Image();
        snakeTailImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30"><rect x="5" y="5" width="20" height="20" fill="%23008800" stroke="%23007700" stroke-width="2"/></svg>';

        const normalFoodImg = new Image();
        normalFoodImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30"><circle cx="15" cy="15" r="12" fill="%23ff0000" stroke="%23aa0000" stroke-width="2"/><path d="M15,5 L15,25 M5,15 L25,15" stroke="%23ffff00" stroke-width="2"/></svg>';

        const specialFoodImg = new Image();
        specialFoodImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30"><circle cx="15" cy="15" r="12" fill="%23ffff00" stroke="%23ffaa00" stroke-width="2"/><path d="M8,8 L22,22 M8,22 L22,8" stroke="%23ff0000" stroke-width="3"/></svg>';

        function initSnake() {
            snakeCanvas = document.getElementById('snake-canvas');
            snakeCtx = snakeCanvas.getContext('2d');
            
            // Adjust canvas size for mobile
            if (window.innerWidth < 600) {
                snakeCanvas.width = 400;
                snakeCanvas.height = 400;
                snakeSize = 20;
            }
            
            // Initialize snake
            snake = [
                {x: 3 * snakeSize, y: 0, type: 'head'},
                {x: 2 * snakeSize, y: 0, type: 'body'},
                {x: 1 * snakeSize, y: 0, type: 'body'},
                {x: 0, y: 0, type: 'tail'}
            ];
            
            generateFood();
            snakeDirection = 'right';
            snakeGameOver = false;
            snakeScore = 0;
            specialFood = null;
            snakeParticles = [];
            
            // Add event listeners for keyboard controls
            document.removeEventListener('keydown', changeSnakeDirection);
            document.addEventListener('keydown', changeSnakeDirection);
            
            // Start game loop
            lastRenderTime = 0;
            window.requestAnimationFrame(snakeGameLoop);
        }

        function snakeGameLoop(currentTime) {
            if (snakeGameOver) return;
            
            window.requestAnimationFrame(snakeGameLoop);
            
            const secondsSinceLastRender = (currentTime - lastRenderTime) / 1000;
            if (secondsSinceLastRender < 1 / snakeSpeed) return;
            
            lastRenderTime = currentTime;
            
            updateSnake();
            drawSnake();
            
            // Update special food timer
            if (specialFood) {
                specialFoodTimer += secondsSinceLastRender;
                if (specialFoodTimer > 10) { // Special food disappears after 10 seconds
                    specialFood = null;
                    specialFoodTimer = 0;
                }
            } else if (Math.random() < 0.005) { // 0.5% chance per frame to spawn special food
                generateSpecialFood();
            }
            
            // Update particles
            updateParticles();
        }

        function updateSnake() {
            // Create new head based on direction
            const oldHead = snake[0];
            const head = {x: oldHead.x, y: oldHead.y, type: 'head'};
            
            switch(snakeDirection) {
                case 'up':
                    head.y -= snakeSize;
                    break;
                case 'down':
                    head.y += snakeSize;
                    break;
                case 'left':
                    head.x -= snakeSize;
                    break;
                case 'right':
                    head.x += snakeSize;
                    break;
            }
            
            // Check collision with walls (now wraps around)
            if (head.x < 0) head.x = snakeCanvas.width - snakeSize;
            if (head.y < 0) head.y = snakeCanvas.height - snakeSize;
            if (head.x >= snakeCanvas.width) head.x = 0;
            if (head.y >= snakeCanvas.height) head.y = 0;
            
            // Check collision with self
            for (let i = 0; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    snakeGameOver = true;
                    createExplosion(head.x, head.y);
                    setTimeout(() => alert(`GAME OVER! Score: ${snakeScore}`), 100);
                    return;
                }
            }
            
            // Change old head to body
            oldHead.type = 'body';
            
            // Add new head
            snake.unshift(head);
            
            // Check if snake ate food
            let ateFood = false;
            if (head.x === food.x && head.y === food.y) {
                ateFood = true;
                snakeScore += 10;
                generateFood();
                createParticles(food.x, food.y, '#ff0000');
            }
            
            // Check if snake ate special food
            if (specialFood && head.x === specialFood.x && head.y === specialFood.y) {
                ateFood = true;
                snakeScore += 50;
                specialFood = null;
                specialFoodTimer = 0;
                createParticles(specialFood.x, specialFood.y, '#ffff00');
                // Speed boost effect
                snakeSpeed = 15;
                setTimeout(() => { snakeSpeed = 10; }, 3000);
            }
            
            if (!ateFood) {
                // Remove tail if no food eaten
                const oldTail = snake.pop();
                // Change new tail's type
                if (snake.length > 0) {
                    snake[snake.length-1].type = 'tail';
                }
                // Create disappearing effect for tail
                createParticles(oldTail.x, oldTail.y, '#00ff00');
            }
        }

        function drawSnake() {
            // Clear canvas with dark grid
            snakeCtx.fillStyle = '#111122';
            snakeCtx.fillRect(0, 0, snakeCanvas.width, snakeCanvas.height);
            
            // Draw grid
            snakeCtx.strokeStyle = '#000033';
            snakeCtx.lineWidth = 1;
            for (let x = 0; x < snakeCanvas.width; x += snakeSize) {
                snakeCtx.beginPath();
                snakeCtx.moveTo(x, 0);
                snakeCtx.lineTo(x, snakeCanvas.height);
                snakeCtx.stroke();
            }
            for (let y = 0; y < snakeCanvas.height; y += snakeSize) {
                snakeCtx.beginPath();
                snakeCtx.moveTo(0, y);
                snakeCtx.lineTo(snakeCanvas.width, y);
                snakeCtx.stroke();
            }
            
            // Draw snake
            snake.forEach((segment, index) => {
                let img;
                if (segment.type === 'head') {
                    img = snakeHeadImg;
                    // Draw eyes based on direction
                    snakeCtx.save();
                    snakeCtx.translate(segment.x + snakeSize/2, segment.y + snakeSize/2);
                    switch(snakeDirection) {
                        case 'up': snakeCtx.rotate(-Math.PI/2); break;
                        case 'down': snakeCtx.rotate(Math.PI/2); break;
                        case 'left': snakeCtx.rotate(Math.PI); break;
                        case 'right': break;
                    }
                    snakeCtx.drawImage(img, -snakeSize/2, -snakeSize/2, snakeSize, snakeSize);
                    snakeCtx.restore();
                } else if (segment.type === 'tail') {
                    img = snakeTailImg;
                    snakeCtx.drawImage(img, segment.x, segment.y, snakeSize, snakeSize);
                } else {
                    img = snakeBodyImg;
                    snakeCtx.drawImage(img, segment.x, segment.y, snakeSize, snakeSize);
                }
            });
            
            // Draw food
            snakeCtx.drawImage(normalFoodImg, food.x, food.y, snakeSize, snakeSize);
            
            // Draw special food if it exists
            if (specialFood) {
                const pulse = Math.sin(Date.now() / 200) * 0.1 + 1;
                snakeCtx.save();
                snakeCtx.translate(specialFood.x + snakeSize/2, specialFood.y + snakeSize/2);
                snakeCtx.scale(pulse, pulse);
                snakeCtx.drawImage(specialFoodImg, -snakeSize/2, -snakeSize/2, snakeSize, snakeSize);
                snakeCtx.restore();
                
                // Draw timer
                const timeLeft = 10 - specialFoodTimer;
                snakeCtx.fillStyle = '#ffff00';
                snakeCtx.font = '12px "Press Start 2P"';
                snakeCtx.fillText(timeLeft.toFixed(1), specialFood.x, specialFood.y - 5);
            }
            
            // Draw particles
            drawParticles();
            
            // Draw score
            snakeCtx.fillStyle = '#00ff00';
            snakeCtx.font = '20px "Press Start 2P"';
            snakeCtx.fillText(`SCORE: ${snakeScore}`, 20, 30);
            
            // Draw speed
            snakeCtx.fillStyle = snakeSpeed > 10 ? '#ffff00' : '#ffffff';
            snakeCtx.font = '12px "Press Start 2P"';
            snakeCtx.fillText(`SPEED: ${snakeSpeed}`, 20, 50);
        }

        function generateFood() {
            const maxX = Math.floor(snakeCanvas.width / snakeSize);
            const maxY = Math.floor(snakeCanvas.height / snakeSize);
            
            food = {
                x: Math.floor(Math.random() * maxX) * snakeSize,
                y: Math.floor(Math.random() * maxY) * snakeSize
            };
            
            // Make sure food doesn't appear on snake
            for (let segment of snake) {
                if (segment.x === food.x && segment.y === food.y) {
                    return generateFood();
                }
            }
        }

        function generateSpecialFood() {
            const maxX = Math.floor(snakeCanvas.width / snakeSize);
            const maxY = Math.floor(snakeCanvas.height / snakeSize);
            
            specialFood = {
                x: Math.floor(Math.random() * maxX) * snakeSize,
                y: Math.floor(Math.random() * maxY) * snakeSize
            };
            
            specialFoodTimer = 0;
            
            // Make sure special food doesn't appear on snake or normal food
            for (let segment of snake) {
                if (segment.x === specialFood.x && segment.y === specialFood.y) {
                    return generateSpecialFood();
                }
            }
            if (food.x === specialFood.x && food.y === specialFood.y) {
                return generateSpecialFood();
            }
        }

        function changeSnakeDirection(e) {
            const key = e.keyCode;
            
            // Prevent reverse direction
            if (key === 37 && snakeDirection !== 'right') {
                snakeDirection = 'left';
            } else if (key === 38 && snakeDirection !== 'down') {
                snakeDirection = 'up';
            } else if (key === 39 && snakeDirection !== 'left') {
                snakeDirection = 'right';
            } else if (key === 40 && snakeDirection !== 'up') {
                snakeDirection = 'down';
            }
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                snakeParticles.push({
                    x: x + snakeSize/2,
                    y: y + snakeSize/2,
                    size: Math.random() * 3 + 1,
                    color: color,
                    speedX: (Math.random() - 0.5) * 5,
                    speedY: (Math.random() - 0.5) * 5,
                    life: 30
                });
            }
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 50; i++) {
                snakeParticles.push({
                    x: x + snakeSize/2,
                    y: y + snakeSize/2,
                    size: Math.random() * 5 + 2,
                    color: `hsl(${Math.random() * 60}, 100%, 50%)`,
                    speedX: (Math.random() - 0.5) * 10,
                    speedY: (Math.random() - 0.5) * 10,
                    life: 60
                });
            }
        }

        function updateParticles() {
            for (let i = 0; i < snakeParticles.length; i++) {
                snakeParticles[i].x += snakeParticles[i].speedX;
                snakeParticles[i].y += snakeParticles[i].speedY;
                snakeParticles[i].life--;
                
                if (snakeParticles[i].life <= 0) {
                    snakeParticles.splice(i, 1);
                    i--;
                }
            }
        }

        function drawParticles() {
            snakeParticles.forEach(particle => {
                snakeCtx.globalAlpha = particle.life / 60;
                snakeCtx.fillStyle = particle.color;
                snakeCtx.beginPath();
                snakeCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                snakeCtx.fill();
                snakeCtx.globalAlpha = 1;
            });
        }

        // ======================
        // ENHANCED CAR RACING GAME
        // ======================
        let carCanvas, carCtx;
        let carX, carY;
        let roadOffset = 0;
        let obstacles = [];
        let carScore = 0;
        let carGameOver = false;
        let carSpeed = 5;
        let obstacleSpeed = 3;
        let lastObstacleTime = 0;
        let roadLines = [];
        let carParticles = [];
        let nitroActive = false;
        let nitroTime = 0;

        // Car sprites
        const playerCarImg = new Image();
        playerCarImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="60" height="100"><rect x="5" y="20" width="50" height="60" fill="%230000ff" stroke="%23000088" stroke-width="3"/><rect x="15" y="10" width="30" height="20" fill="%230000ff" stroke="%23000088" stroke-width="3"/><circle cx="15" cy="90" r="10" fill="%23000"/><circle cx="45" cy="90" r="10" fill="%23000"/><rect x="10" y="15" width="40" height="10" fill="%2388f"/></svg>';

        const obstacleCar1Img = new Image();
        obstacleCar1Img.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="60" height="100"><rect x="5" y="20" width="50" height="60" fill="%23ff0000" stroke="%23880000" stroke-width="3"/><rect x="15" y="10" width="30" height="20" fill="%23ff0000" stroke="%23880000" stroke-width="3"/><circle cx="15" cy="90" r="10" fill="%23000"/><circle cx="45" cy="90" r="10" fill="%23000"/><rect x="10" y="15" width="40" height="10" fill="%23f88"/></svg>';

        const obstacleCar2Img = new Image();
        obstacleCar2Img.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="60" height="100"><rect x="5" y="20" width="50" height="60" fill="%23ff8800" stroke="%23aa5500" stroke-width="3"/><rect x="15" y="10" width="30" height="20" fill="%23ff8800" stroke="%23aa5500" stroke-width="3"/><circle cx="15" cy="90" r="10" fill="%23000"/><circle cx="45" cy="90" r="10" fill="%23000"/><rect x="10" y="15" width="40" height="10" fill="%23ffcc00"/></svg>';

        function initCarRacing() {
            carCanvas = document.getElementById('car-canvas');
            carCtx = carCanvas.getContext('2d');
            
            // Adjust canvas size for mobile
            if (window.innerWidth < 600) {
                carCanvas.width = 350;
                carCanvas.height = 600;
            }
            
            // Initialize car position (center bottom)
            carX = carCanvas.width / 2 - 30;
            carY = carCanvas.height - 120;
            
            obstacles = [];
            roadLines = [];
            carParticles = [];
            carScore = 0;
            carGameOver = false;
            carSpeed = 5;
            obstacleSpeed = 3;
            nitroActive = false;
            
            // Initialize road lines
            for (let y = -50; y < carCanvas.height; y += 100) {
                roadLines.push({y: y});
            }
            
            // Add event listeners for keyboard controls
            document.removeEventListener('keydown', handleCarInput);
            document.addEventListener('keydown', handleCarInput);
            
            // Start game loop
            carGameLoop();
        }

        function carGameLoop() {
            if (carGameOver) return;
            
            updateCarGame();
            drawCarGame();
            
            requestAnimationFrame(carGameLoop);
        }

        function updateCarGame() {
            // Move road
            roadOffset += carSpeed;
            if (roadOffset >= 100) roadOffset = 0;
            
            // Update road lines
            for (let line of roadLines) {
                line.y += carSpeed;
                if (line.y > carCanvas.height) {
                    line.y = -50;
                }
            }
            
            // Move obstacles
            for (let i = 0; i < obstacles.length; i++) {
                obstacles[i].y += obstacleSpeed;
                
                // Check collision with car
                if (
                    carX < obstacles[i].x + 50 &&
                    carX + 50 > obstacles[i].x &&
                    carY < obstacles[i].y + 80 &&
                    carY + 100 > obstacles[i].y
                ) {
                    carGameOver = true;
                    createCarExplosion(carX + 25, carY + 50);
                    setTimeout(() => alert('CRASH! Score: ' + carScore), 100);
                    return;
                }
                
                // Remove obstacles that are off screen
                if (obstacles[i].y > carCanvas.height) {
                    obstacles.splice(i, 1);
                    i--;
                    carScore += 5;
                }
            }
            
            // Add new obstacles
            const currentTime = Date.now();
            if (currentTime - lastObstacleTime > 1500) {
                addObstacle();
                lastObstacleTime = currentTime;
                
                // Increase difficulty
                if (carScore > 0 && carScore % 25 === 0) {
                    obstacleSpeed += 0.5;
                }
            }
            
            // Update nitro
            if (nitroActive) {
                nitroTime--;
                if (nitroTime <= 0) {
                    nitroActive = false;
                    carSpeed = 5;
                }
                
                // Add nitro particles
                if (Math.random() < 0.3) {
                    carParticles.push({
                        x: carX + 15 + Math.random() * 30,
                        y: carY + 100,
                        size: Math.random() * 5 + 2,
                        color: `hsl(${Math.random() * 20 + 20}, 100%, 50%)`,
                        speedX: (Math.random() - 0.5) * 2,
                        speedY: Math.random() * 3 + 2,
                        life: 30
                    });
                }
            }
            
            // Update particles
            updateCarParticles();
        }

        function drawCarGame() {
            // Draw sky gradient
            const skyGradient = carCtx.createLinearGradient(0, 0, 0, carCanvas.height);
            skyGradient.addColorStop(0, '#001133');
            skyGradient.addColorStop(1, '#000011');
            carCtx.fillStyle = skyGradient;
            carCtx.fillRect(0, 0, carCanvas.width, carCanvas.height);
            
            // Draw distant mountains
            carCtx.fillStyle = '#000033';
            for (let i = 0; i < 5; i++) {
                const mountainX = (i * carCanvas.width/4) - (roadOffset * 0.2 % carCanvas.width/4);
                const mountainWidth = carCanvas.width/3;
                const mountainHeight = 100 + Math.sin(i) * 30;
                carCtx.beginPath();
                carCtx.moveTo(mountainX, carCanvas.height);
                carCtx.lineTo(mountainX + mountainWidth/2, carCanvas.height - mountainHeight);
                carCtx.lineTo(mountainX + mountainWidth, carCanvas.height);
                carCtx.fill();
            }
            
            // Draw road
            carCtx.fillStyle = '#333333';
            carCtx.fillRect(50, 0, carCanvas.width - 100, carCanvas.height);
            
            // Draw road lines
            carCtx.fillStyle = '#ffffff';
            for (let line of roadLines) {
                carCtx.fillRect(carCanvas.width / 2 - 5, line.y, 10, 50);
            }
            
            // Draw side lines
            carCtx.strokeStyle = '#ff0';
            carCtx.lineWidth = 5;
            carCtx.beginPath();
            carCtx.moveTo(50, 0);
            carCtx.lineTo(50, carCanvas.height);
            carCtx.moveTo(carCanvas.width - 50, 0);
            carCtx.lineTo(carCanvas.width - 50, carCanvas.height);
            carCtx.stroke();
            
            // Draw particles
            drawCarParticles();
            
            // Draw obstacles
            for (let obstacle of obstacles) {
                const img = obstacle.type === 1 ? obstacleCar1Img : obstacleCar2Img;
                carCtx.drawImage(img, obstacle.x, obstacle.y, 60, 100);
            }
            
            // Draw car with nitro effect
            carCtx.save();
            if (nitroActive) {
                const nitroGlow = carCtx.createRadialGradient(
                    carX + 30, carY + 100, 10,
                    carX + 30, carY + 100, 30
                );
                nitroGlow.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
                nitroGlow.addColorStop(1, 'rgba(255, 100, 0, 0)');
                carCtx.fillStyle = nitroGlow;
                carCtx.fillRect(carX - 20, carY + 80, 100, 50);
            }
            carCtx.drawImage(playerCarImg, carX, carY, 60, 100);
            carCtx.restore();
            
            // Draw score
            carCtx.fillStyle = '#ffffff';
            carCtx.font = '20px "Press Start 2P"';
            carCtx.fillText('SCORE: ' + carScore, 20, 30);
            
            // Draw speed
            carCtx.fillStyle = nitroActive ? '#ff8800' : '#ffffff';
            carCtx.font = '16px "Press Start 2P"';
            carCtx.fillText('SPEED: ' + Math.floor(carSpeed * 10), 20, 60);
            
            // Draw nitro status
            if (nitroActive) {
                carCtx.fillStyle = '#ff8800';
                carCtx.fillText('NITRO: ' + Math.ceil(nitroTime/60), 20, 90);
            }
        }

        function handleCarInput(e) {
            const key = e.keyCode;
            const moveAmount = 60;
            
            if (key === 37 && carX > 60) { // Left
                carX -= moveAmount;
            } else if (key === 39 && carX < carCanvas.width - 120) { // Right
                carX += moveAmount;
            } else if (key === 32 && !nitroActive) { // Space for nitro
                activateNitro();
            }
        }

        function activateNitro() {
            nitroActive = true;
            nitroTime = 180; // 3 seconds at 60fps
            carSpeed = 8;
        }

        function addObstacle() {
            const lane1 = 60;
            const lane2 = carCanvas.width / 2 - 30;
            const lane3 = carCanvas.width - 120;
            
            const lanes = [lane1, lane2, lane3];
            const randomLane = lanes[Math.floor(Math.random() * lanes.length)];
            
            obstacles.push({
                x: randomLane,
                y: -100,
                type: Math.random() > 0.5 ? 1 : 2
            });
        }

        function createCarExplosion(x, y) {
            for (let i = 0; i < 50; i++) {
                carParticles.push({
                    x: x,
                    y: y,
                    size: Math.random() * 8 + 3,
                    color: `hsl(${Math.random() * 30}, 100%, 50%)`,
                    speedX: (Math.random() - 0.5) * 10,
                    speedY: (Math.random() - 0.5) * 10,
                    life: 60
                });
            }
        }

        function updateCarParticles() {
            for (let i = 0; i < carParticles.length; i++) {
                carParticles[i].x += carParticles[i].speedX;
                carParticles[i].y += carParticles[i].speedY;
                carParticles[i].life--;
                
                if (carParticles[i].life <= 0) {
                    carParticles.splice(i, 1);
                    i--;
                }
            }
        }

        function drawCarParticles() {
            carParticles.forEach(particle => {
                carCtx.globalAlpha = particle.life / 60;
                carCtx.fillStyle = particle.color;
                carCtx.beginPath();
                carCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                carCtx.fill();
                carCtx.globalAlpha = 1;
            });
        }

        // ======================
        // ENHANCED T-REX RUNNER
        // ======================
        let trexCanvas, trexCtx;
        let trexX, trexY;
        let trexJumping = false;
        let trexJumpVelocity = 0;
        let trexGravity = 0.5;
        let cacti = [];
        let trexScore = 0;
        let trexGameOver = false;
        let trexSpeed = 5;
        let lastCactusTime = 0;
        let groundY;
        let clouds = [];
        let stars = [];
        let isDay = true;
        let dayNightCycle = 0;
        let trexParticles = [];
        let trexDucking = false;

        // T-Rex sprites
        const trexRun1Img = new Image();
        trexRun1Img.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="80" height="100"><rect x="20" y="30" width="40" height="50" fill="%23333" stroke="%23000" stroke-width="2"/><rect x="30" y="10" width="20" height="30" fill="%23333" stroke="%23000" stroke-width="2"/><rect x="10" y="60" width="20" height="10" fill="%23333" stroke="%23000" stroke-width="2"/><rect x="50" y="60" width="20" height="10" fill="%23333" stroke="%23000" stroke-width="2"/><rect x="15" y="55" width="10" height="5" fill="%23333" stroke="%23000" stroke-width="1"/><rect x="55" y="55" width="10" height="5" fill="%23333" stroke="%23000" stroke-width="1"/></svg>';

        const trexRun2Img = new Image();
        trexRun2Img.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="80" height="100"><rect x="20" y="30" width="40" height="50" fill="%23333" stroke="%23000" stroke-width="2"/><rect x="30" y="10" width="20" height="30" fill="%23333" stroke="%23000" stroke-width="2"/><rect x="10" y="70" width="20" height="10" fill="%23333" stroke="%23000" stroke-width="2"/><rect x="50" y="50" width="20" height="10" fill="%23333" stroke="%23000" stroke-width="2"/><rect x="15" y="65" width="10" height="5" fill="%23333" stroke="%23000" stroke-width="1"/><rect x="55" y="45" width="10" height="5" fill="%23333" stroke="%23000" stroke-width="1"/></svg>';

        const trexDuckImg = new Image();
        trexDuckImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="80" height="60"><rect x="20" y="10" width="40" height="40" fill="%23333" stroke="%23000" stroke-width="2"/><rect x="10" y="30" width="20" height="10" fill="%23333" stroke="%23000" stroke-width="2"/><rect x="50" y="30" width="20" height="10" fill="%23333" stroke="%23000" stroke-width="2"/><rect x="15" y="25" width="10" height="5" fill="%23333" stroke="%23000" stroke-width="1"/><rect x="55" y="25" width="10" height="5" fill="%23333" stroke="%23000" stroke-width="1"/></svg>';

        const cactusSmallImg = new Image();
        cactusSmallImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="50"><rect x="10" y="10" width="10" height="40" fill="%2300aa00" stroke="%23007700" stroke-width="2"/><rect x="5" y="15" width="20" height="10" fill="%2300aa00" stroke="%23007700" stroke-width="2"/></svg>';

        const cactusLargeImg = new Image();
        cactusLargeImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="50" height="70"><rect x="20" y="10" width="10" height="60" fill="%2300aa00" stroke="%23007700" stroke-width="2"/><rect x="5" y="20" width="40" height="10" fill="%2300aa00" stroke="%23007700" stroke-width="2"/><rect x="15" y="40" width="20" height="10" fill="%2300aa00" stroke="%23007700" stroke-width="2"/></svg>';

        const cactusGroupImg = new Image();
        cactusGroupImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="70" height="50"><rect x="10" y="10" width="10" height="40" fill="%2300aa00" stroke="%23007700" stroke-width="2"/><rect x="25" y="15" width="10" height="35" fill="%2300aa00" stroke="%23007700" stroke-width="2"/><rect x="40" y="5" width="10" height="45" fill="%2300aa00" stroke="%23007700" stroke-width="2"/><rect x="5" y="20" width="20" height="10" fill="%2300aa00" stroke="%23007700" stroke-width="2"/><rect x="35" y="30" width="20" height="10" fill="%2300aa00" stroke="%23007700" stroke-width="2"/></svg>';

        function initTrex() {
            trexCanvas = document.getElementById('trex-canvas');
            trexCtx = trexCanvas.getContext('2d');
            
            // Adjust canvas size for mobile
            if (window.innerWidth < 600) {
                trexCanvas.width = 400;
                trexCanvas.height = 200;
            }
            
            groundY = trexCanvas.height - 30;
            
            // Initialize trex position
            trexX = 50;
            trexY = groundY - 80;
            
            cacti = [];
            clouds = [];
            stars = [];
            trexParticles = [];
            trexScore = 0;
            trexGameOver = false;
            trexJumping = false;
            trexDucking = false;
            trexSpeed = 5;
            isDay = true;
            dayNightCycle = 0;
            
            // Create initial clouds
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * trexCanvas.width,
                    y: Math.random() * 50,
                    width: 50 + Math.random() * 50,
                    speed: 0.5 + Math.random()
                });
            }
            
            // Create stars for night
            for (let i = 0; i < 50; i++) {
                stars.push({
                    x: Math.random() * trexCanvas.width,
                    y: Math.random() * (trexCanvas.height - 50),
                    size: Math.random() * 2 + 1,
                    brightness: Math.random()
                });
            }
            
            // Add event listeners for keyboard controls
            document.removeEventListener('keydown', handleTrexInput);
            document.addEventListener('keydown', handleTrexInput);
            
            // Start game loop
            trexGameLoop();
        }

        function trexGameLoop() {
            if (trexGameOver) return;
            
            updateTrexGame();
            drawTrexGame();
            
            requestAnimationFrame(trexGameLoop);
        }

        function updateTrexGame() {
            // Handle day/night cycle
            dayNightCycle++;
            if (dayNightCycle >= 1000) {
                dayNightCycle = 0;
                isDay = !isDay;
            }
            
            // Update clouds
            for (let i = 0; i < clouds.length; i++) {
                clouds[i].x -= clouds[i].speed;
                if (clouds[i].x + clouds[i].width < 0) {
                    clouds[i].x = trexCanvas.width;
                    clouds[i].y = Math.random() * 50;
                    clouds[i].width = 50 + Math.random() * 50;
                }
            }
            
            // Handle jumping
            if (trexJumping) {
                trexY += trexJumpVelocity;
                trexJumpVelocity += trexGravity;
                
                // Check if landed
                if (trexY >= groundY - (trexDucking ? 40 : 80)) {
                    trexY = groundY - (trexDucking ? 40 : 80);
                    trexJumping = false;
                    createTrexParticles(trexX + 40, groundY, 10);
                }
            }
            
            // Move cacti
            for (let i = 0; i < cacti.length; i++) {
                cacti[i].x -= trexSpeed;
                
                // Check collision with trex
                const trexHeight = trexDucking ? 40 : 80;
                const trexWidth = trexDucking ? 60 : 40;
                
                if (
                    trexX + trexWidth > cacti[i].x &&
                    trexX < cacti[i].x + cacti[i].width &&
                    trexY + trexHeight > groundY - cacti[i].height
                ) {
                    trexGameOver = true;
                    createTrexExplosion(trexX + 40, trexY + 40);
                    setTimeout(() => alert('GAME OVER! Score: ' + trexScore), 100);
                    return;
                }
                
                // Remove cacti that are off screen
                if (cacti[i].x + cacti[i].width < 0) {
                    cacti.splice(i, 1);
                    i--;
                    trexScore++;
                }
            }
            
            // Add new cacti
            const currentTime = Date.now();
            if (currentTime - lastCactusTime > 1500 - Math.min(trexScore, 30) * 20) {
                addCactus();
                lastCactusTime = currentTime;
                
                // Increase difficulty
                if (trexScore > 0 && trexScore % 10 === 0) {
                    trexSpeed += 0.2;
                }
            }
            
            // Update particles
            updateTrexParticles();
        }

        function drawTrexGame() {
            // Draw sky
            if (isDay) {
                const dayGradient = trexCtx.createLinearGradient(0, 0, 0, trexCanvas.height);
                const cycleProgress = dayNightCycle / 1000;
                
                if (cycleProgress < 0.1 || cycleProgress > 0.9) { // Sunrise/sunset
                    dayGradient.addColorStop(0, '#ff9966');
                    dayGradient.addColorStop(1, '#ffcc99');
                } else { // Daytime
                    dayGradient.addColorStop(0, '#87CEEB');
                    dayGradient.addColorStop(1, '#E0F7FF');
                }
                trexCtx.fillStyle = dayGradient;
            } else {
                // Night sky
                trexCtx.fillStyle = '#000033';
            }
            trexCtx.fillRect(0, 0, trexCanvas.width, trexCanvas.height);
            
            // Draw stars at night
            if (!isDay) {
                stars.forEach(star => {
                    const twinkle = Math.sin(Date.now() / 1000 + star.x) * 0.3 + 0.7;
                    trexCtx.globalAlpha = star.brightness * twinkle;
                    trexCtx.fillStyle = '#ffffff';
                    trexCtx.fillRect(star.x, star.y, star.size, star.size);
                });
                trexCtx.globalAlpha = 1;
            }
            
            // Draw sun/moon
            const cyclePos = (dayNightCycle / 1000) * trexCanvas.width;
            trexCtx.beginPath();
            if (isDay) {
                trexCtx.fillStyle = '#ffff00';
                trexCtx.arc(cyclePos, 50, 30, 0, Math.PI * 2);
            } else {
                trexCtx.fillStyle = '#dddddd';
                trexCtx.arc(trexCanvas.width - cyclePos, 50, 25, 0, Math.PI * 2);
            }
            trexCtx.fill();
            
            // Draw clouds
            trexCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            clouds.forEach(cloud => {
                trexCtx.beginPath();
                trexCtx.ellipse(cloud.x, cloud.y, cloud.width/2, 20, 0, 0, Math.PI * 2);
                trexCtx.fill();
                trexCtx.beginPath();
                trexCtx.ellipse(cloud.x + cloud.width/3, cloud.y - 10, cloud.width/3, 20, 0, 0, Math.PI * 2);
                trexCtx.fill();
            });
            
            // Draw ground
            trexCtx.fillStyle = isDay ? '#8B4513' : '#5a2d0b';
            trexCtx.fillRect(0, groundY, trexCanvas.width, trexCanvas.height - groundY);
            
            // Draw ground details
            trexCtx.strokeStyle = isDay ? '#a0522d' : '#703c0d';
            trexCtx.lineWidth = 2;
            for (let x = 0; x < trexCanvas.width; x += 20) {
                const height = Math.sin(x / 50 + Date.now() / 1000) * 5;
                trexCtx.beginPath();
                trexCtx.moveTo(x, groundY);
                trexCtx.lineTo(x, groundY + height);
                trexCtx.stroke();
            }
            
            // Draw particles
            drawTrexParticles();
            
            // Draw cacti
            cacti.forEach(cactus => {
                if (cactus.type === 'small') {
                    trexCtx.drawImage(cactusSmallImg, cactus.x, groundY - cactus.height, 30, cactus.height);
                } else if (cactus.type === 'large') {
                    trexCtx.drawImage(cactusLargeImg, cactus.x, groundY - cactus.height, 50, cactus.height);
                } else {
                    trexCtx.drawImage(cactusGroupImg, cactus.x, groundY - cactus.height, 70, cactus.height);
                }
            });
            
            // Draw trex
            const frameTime = Date.now() / 100;
            if (trexDucking) {
                trexCtx.drawImage(trexDuckImg, trexX, trexY, 80, 60);
            } else if (trexJumping) {
                trexCtx.drawImage(trexRun1Img, trexX, trexY, 80, 100);
            } else {
                if (Math.floor(frameTime) % 2 === 0) {
                    trexCtx.drawImage(trexRun1Img, trexX, trexY, 80, 100);
                } else {
                    trexCtx.drawImage(trexRun2Img, trexX, trexY, 80, 100);
                }
            }
            
            // Draw score
            trexCtx.fillStyle = isDay ? '#000000' : '#ffffff';
            trexCtx.font = '20px "Press Start 2P"';
            trexCtx.fillText('SCORE: ' + trexScore, 20, 30);
            
            // Draw speed
            trexCtx.fillStyle = isDay ? '#333333' : '#cccccc';
            trexCtx.font = '16px "Press Start 2P"';
            trexCtx.fillText('SPEED: ' + Math.floor(trexSpeed), 20, 60);
            
            // Draw instruction when game starts
            if (trexScore === 0 && cacti.length === 0) {
                trexCtx.fillStyle = isDay ? '#000000' : '#ffffff';
                trexCtx.font = '14px "Press Start 2P"';
                trexCtx.fillText('PRESS SPACE TO JUMP', trexCanvas.width/2 - 150, 50);
                trexCtx.fillText('PRESS DOWN TO DUCK', trexCanvas.width/2 - 140, 80);
            }
        }

        function handleTrexInput(e) {
            const key = e.keyCode;
            
            if ((key === 32 || key === 38) && !trexJumping) { // Space or Up to jump
                trexJumping = true;
                trexJumpVelocity = -12;
                trexDucking = false;
                createTrexParticles(trexX + 40, groundY, 5);
            } else if (key === 40) { // Down to duck
                if (!trexJumping) {
                    trexDucking = true;
                } else if (trexJumping && !trexDucking) { // Fast fall when jumping
                    trexJumpVelocity = Math.max(trexJumpVelocity, 5);
                }
            }
        }

        function addCactus() {
            const types = ['small', 'large', 'group'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let width, height;
            switch(type) {
                case 'small':
                    width = 30;
                    height = 50;
                    break;
                case 'large':
                    width = 50;
                    height = 70;
                    break;
                case 'group':
                    width = 70;
                    height = 50;
                    break;
            }
            
            cacti.push({
                x: trexCanvas.width,
                width: width,
                height: height,
                type: type
            });
        }

        function createTrexParticles(x, y, count) {
            for (let i = 0; i < count; i++) {
                trexParticles.push({
                    x: x,
                    y: y,
                    size: Math.random() * 3 + 1,
                    color: isDay ? '#8B4513' : '#5a2d0b',
                    speedX: (Math.random() - 0.5) * 3,
                    speedY: -Math.random() * 2,
                    life: 30
                });
            }
        }

        function createTrexExplosion(x, y) {
            for (let i = 0; i < 30; i++) {
                trexParticles.push({
                    x: x,
                    y: y,
                    size: Math.random() * 5 + 2,
                    color: `hsl(${Math.random() * 60}, 100%, ${Math.random() * 30 + 20}%)`,
                    speedX: (Math.random() - 0.5) * 8,
                    speedY: (Math.random() - 0.5) * 8,
                    life: 60
                });
            }
        }

        function updateTrexParticles() {
            for (let i = 0; i < trexParticles.length; i++) {
                trexParticles[i].x += trexParticles[i].speedX;
                trexParticles[i].y += trexParticles[i].speedY;
                trexParticles[i].life--;
                
                if (trexParticles[i].life <= 0) {
                    trexParticles.splice(i, 1);
                    i--;
                }
            }
        }

        function drawTrexParticles() {
            trexParticles.forEach(particle => {
                trexCtx.globalAlpha = particle.life / 60;
                trexCtx.fillStyle = particle.color;
                trexCtx.beginPath();
                trexCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                trexCtx.fill();
                trexCtx.globalAlpha = 1;
            });
        }
    
// Enable mobile direction control
function setDirection(dir) {
    if (
        (dir === 'left' && snakeDirection !== 'right') ||
        (dir === 'right' && snakeDirection !== 'left') ||
        (dir === 'up' && snakeDirection !== 'down') ||
        (dir === 'down' && snakeDirection !== 'up')
    ) {
        snakeDirection = dir;
    }
}


// Enable mobile direction control for CAR
function setCarDirection(dir) {
    if (gameActive === 'car') {
        if (dir === 'left' && carX > 60) carX -= 60;
        else if (dir === 'right' && carX < carCanvas.width - 120) carX += 60;
        else if (dir === 'up' && !false) {
            false = true;
            0 = -12;
            false = false;
        } else if (dir === 'down') {
            if (!false) false = true;
            else 0 = Math.max(0, 5);
        }
    }
}


// Enable mobile direction control for TREX
function setTrexDirection(dir) {
    if (gameActive === 'trex') {
        if (dir === 'left' && trexX > 0) trexX -= 10;
        else if (dir === 'right' && trexX < trexCanvas.width - 80) trexX += 10;
        else if (dir === 'up' && !trexJumping) {
            trexJumping = true;
            trexJumpVelocity = -12;
            trexDucking = false;
        } else if (dir === 'down') {
            if (!trexJumping) trexDucking = true;
            else trexJumpVelocity = Math.max(trexJumpVelocity, 5);
        }
    }
}

</script>
</body>
</html>